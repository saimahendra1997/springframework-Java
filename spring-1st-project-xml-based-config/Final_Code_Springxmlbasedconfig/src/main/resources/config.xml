<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien" scope="prototype"></bean>-->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien">-->
<!--        <property name="age" value="28"></property>-->
<!--        <property name="laptop" ref="lap"></property>-->
<!--    </bean>-->

<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien">-->
<!--&lt;!&ndash;        I don't want to use the property tag now. So when I use property tag basically it uses the setter.We have to use something called a constructor-arg;-->
<!--        <constructor-arg value="28"></constructor-arg>-->
<!--        <constructor-arg ref="lap"></constructor-arg>-->
<!--    </bean>-->

    <!--   1st  way of Constructor argument checking by type. because it was even not checking the type, it was checking the sequence. -->
<!--    It works only if we have 2 different types. There is an issue if we have same type with one more parameter-->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien">-->
<!--        &lt;!&ndash;        I don't want to use the property tag now. So when I use property tag basically it uses the setter.We have to use something called a constructor-arg;-->
<!--        <constructor-arg type="org.springframeworkxmlbasedconfig.Laptop" ref="lap"></constructor-arg>-->
<!--        <constructor-arg type="int" value="28"></constructor-arg>-->
<!--    </bean>-->

<!--// This can be solved by using index or by names-->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien">-->
        <!--        I don't want to use the property tag now. So when I use property tag basically it uses the setter.We have to use something called a constructor-arg-->
<!--            If we use index no need to follow the sequence again-->
<!--        <constructor-arg index="1" ref="lap"></constructor-arg>-->
<!--        <constructor-arg index="0" value="28"></constructor-arg>-->

<!--        If we use name we have to follow the sequence-->
<!--        Again if we want to use the name properties and don't want to follow the sequence we have to annotate the constructor with @ConstructorProperties({"age", "laptop"})-->
<!--        <constructor-arg name="laptop" ref="lap"></constructor-arg>-->
<!--        <constructor-arg name="age" value="28"></constructor-arg>-->
<!--    </bean>-->


<!--    For the Autowiring and Interface Based Object Passing we are using Property not the constructor args-->
<!--    // 1st solution It works-->
<!--        <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien">-->
<!--            <property name="age" value="28"></property>-->
<!--            <property name="comp" ref="desk"></property>-->
<!--        </bean>-->

<!--    <bean id="alien2" class="org.springframeworkxmlbasedconfig.Alien"></bean>-->
<!--    <bean id="lap" class="org.springframeworkxmlbasedconfig.Laptop"></bean>-->
<!--    <bean id="desk" class="org.springframeworkxmlbasedconfig.Desktop"></bean>-->


<!--   2nd test - what if we mention the same name and ref both are same-->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien">-->
<!--        <property name="age" value="28"></property>-->
<!--        <property name="comp" ref="comp"></property>-->
<!--    </bean>-->

<!--    <bean id="comp" class="org.springframeworkxmlbasedconfig.Laptop"></bean>-->
<!--    <bean id="desk" class="org.springframeworkxmlbasedconfig.Desktop"></bean>-->
    <!--    It works. Here the output will be Compiling in Laptop because it takes from Laptop-->


    <!--3rd Test - So basically when we specify this, we are creating a wire, or we have a wire between your alien and a laptop.
    But what if I want this wiring to be done automatically, something like autowire and that's possible by name.Now you're saying to spring,
    I want to go for auto wire and try to link them with the help of their names. Actually it is checking with the name  comp (private Computer comp;) -->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien" autowire="byName">-->
<!--        <property name="age" value="28"></property>-->
<!--    </bean>-->

<!--    <bean id="comp" class="org.springframeworkxmlbasedconfig.Laptop"></bean>-->
<!--    <bean id="desk" class="org.springframeworkxmlbasedconfig.Desktop"></bean>-->

    <!--4th Test - Instead of using byName we can also use called byType-->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien" autowire="byType">-->
<!--        <property name="age" value="28"></property>-->
<!--    </bean>-->

<!--    <bean id="comp" class="org.springframeworkxmlbasedconfig.Laptop"></bean>-->
<!--    <bean id="desk" class="org.springframeworkxmlbasedconfig.Desktop"></bean>-->

    <!-- 5th Test - byType cannot work with both checks. It throws error which says expected single matching bean.
    But found two because both the beans are have the same type. They have laptop and desktop which are both of type of computer.that's the confusion-->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien" autowire="byType">-->
<!--        <property name="age" value="28"></property>-->
<!--    </bean>-->
    <!--    <bean id="comp" class="org.springframeworkxmlbasedconfig.Laptop"></bean>-->
<!--    <bean id="desk" class="org.springframeworkxmlbasedconfig.Desktop"></bean>-->


    <!-- Primary bean - As in 5th step we came to know that byType cannot work with both checks. It throws error which says expected single matching bean.
    But found two because both the beans are have the same type. They have laptop and desktop which are both of type of computer.that's the confusion
    Tp fix this we can mention primary = "true"-->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien" autowire="byType">-->
<!--        <property name="age" value="28"/>-->
<!--        But what if you are explicitly mentioning that I'm going to access desk obj. Even if you have by type which says primary is laptop, since you-->
<!--        are mentioning explicitly it will go for desktop.So primary works only when you have a confusion.-->
<!--        <property name="comp" ref="desk"/>-->
<!--    </bean>-->
<!--        <bean id="comp" class="org.springframeworkxmlbasedconfig.Laptop" primary="true"/>-->
<!--    <bean id="desk" class="org.springframeworkxmlbasedconfig.Desktop"/>-->
<!--    Compiling in Laptop...-->


<!--    Lazy Initialization bean-->
<!--    <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien" autowire="byType">-->
<!--        <property name="age" value="28"/>-->
<!--        <property name="comp" ref="lap"/>-->
<!--    </bean>-->
<!--    <bean id="lap" class="org.springframeworkxmlbasedconfig.Laptop" primary="true"/>-->
<!--    <bean id="desk" class="org.springframeworkxmlbasedconfig.Desktop" lazy-init="true"/>-->
<!--    If we look at this even though we are referring to lap object it has to print the Laptop Object got created because we are not using the desktop object-->
<!--    If we see the o/p. The objects got created for all the beans even though we are not using-->
<!--    Alien Object Created...-->
<!--    Desktop Objected Created...-->
<!--    Laptop Object Created...-->
<!--    let's say I have a requirement that I don't want to load the desktop object by default.So the moment you run the container, I don't want this object to be created.-->
<!--    I want this object to be created only when you call it for the first time.To achieve this just go to the bean definition, you can see there is one of the property called lazy-init="true"
        After adding that o/p is Alien Object Created...-->
    <!--    Desktop Objected Created...
    Only when you want to use it, it will be created.That means in Main.java if we specify it explicitly -    Desktop desktop = (Desktop) context.getBean("desk");
    then it will create the desktop object. It is still singleton, but then it will be created only when you want it.
    In prototype, the object gets created only when you ask for it, because you create new object every time you request for it.
    In this scenario, it will also create the object when you want it, but it will be still singleton.

    There is a scenario that alien is dependent on desk as we are seeing that desk is lazy as we know that It will be called only when it is required.
    even if we comment this line // Desktop desktop = (Desktop) context.getBean("desk");. Here we can see that desk is lazy and alien is eager. The question here is
    will the object got created?if you run this code you can see it will say desktop object created. So when you have a non-lazy bean dependent on a lazy-bean,
    still it will create the object of a lazy-bean because someone wants it.

    Why to make bean lazy? - Because in your project we will be having hundreds of beans.Just for an ex, if we have hundreds of beans and if we make every bean as non-lazy by default,
    which is eager, it will. When we are loading the application, it will create object of all those hundred beans. Do we really want those beans?
    That's the question you have to ask. So of course this is something you have to decide as a developer.
    -->


    <!-- Inner Bean
        the only purpose of this laptop being here is to have it reference to the alien. Because alien is dependent on a computer and the implementation for computer is laptop
          What we are doing is we are getting this bean lap, and then we are referring here and it works. But that also means that this particular laptop bean is available for the entire application.
          So any other bean it can be a human, or it can be a car can use this instance of laptop. We just have to refer that. But what if we don't want to do that?
          What if I just want to limit this particular bean only for the alien. We can do that. So basically what I'm doing is I'm creating a comp as property name,
          and then I'm creating this bean inside the property tag. So this bean here is basically an inner bin for the alien. So this alien is an outer bin.
          That means this can be used only by the alien not from the outside.-->
        <bean id="alien1" class="org.springframeworkxmlbasedconfig.Alien" autowire="byType">
        <property name="age" value="28"/>
            <property name="comp">
                <bean id="lap" class="org.springframeworkxmlbasedconfig.Laptop" primary="true"/>
            </property>
        </bean>
<!--        <bean id="lap" class="org.springframeworkxmlbasedconfig.Laptop" primary="true"/>-->

</beans>

        <!--This is where you mention the bean tags. Now in XML we can have our own tags. But then this tag should also make sense for the spring framework.
        Now what I'm going to use to create the bean we have to use a bean tag. So let's say when I say spring framework to manage the beans, which are basically objects
        that are managed by Spring Framework.So I have to mention two things. First, the name of the bean or the ID for the bean and the class.
        So we can mention ID which is alien in this case. Now what is this alien? In Main.Java, when I say get bean, I'm saying alien here. So this is a name it will search for.
        Alien alien = (Alien) context.getBean("alien"); also we have to mention the class name But the fully qualified class name, which means with the help of package as well.

        even in XML we have to use those tags which springs understand and for that you have to define the definitions for this bean.

        If we specify another alien tag. Whether it will create the two objects? Answer is Yes. So it depends upon how many beans you mention here
        Those many objects will create.So if you mention two beans with two different IDs for the same class, it will create two objects

        So even if we don't mention ID it still creates the object. But the question is if we don't have an ID here, how will you refer that here.
        Alien alien = (Alien) context.getBean("alien"). Because when we say get bean you have to mention the ID.


        // Scopes
        So by default it follows singleton which means in your application for this alien there will be only one object created.
        So it doesn't matter how many times you call them. So even if you say getBean thousands of times, it will refer to the same object is because
        we get it Only one object here which is alien1, and we are calling it here.

        But what if we want two objects every time you say getBean, it should create a new object. Now for that you have to change something called a scope.
        Now in the bean there is one more attribute we can add which is called scope.

        One more interesting thing, if you comment the entire code here and if you run this line - ApplicationContext context = new ClassPathXmlApplicationContext("config.xml");
        We only get the output printed is - Laptop Object Created.
        we can see we have not got any object for alien is because when you create this container, it will load this config.XML file.
        It will check for the beans, and we'll be saying, hey, we do have a bean here for alien, right? Why it is not getting the object.
        It's because now the scope is prototyped. So when the scope is singleton, it will create the object by default
        So the moment we load the application, it will load the container, and you will get the object. Because singleton object will be created when the container is loading or has loaded.



         -->